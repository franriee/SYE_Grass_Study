---
title: "Grass Images Histogram Oriented Gradients"
author: "Francesca Mnenula"
format:
  html:
    embed-resources: true
execute:
  error: true
---

# Abstract

We explore the use of Histogram of Oriented Gradients (HOG) to estimate grass orientation from images generated by generative artificial intelligence models. These grass orientations computed with HOG are compared to the wind direction and the grass orientation specified in the AI model's prompt. This preliminary simulation evaluates the HOG method’s ability to recover grass orientation under controlled conditions. These results provide a first step toward potential applications that could help communities monitor changes in local wind patterns from grass images in fields amidst climate-driven environmental changes.

# Motivation

This project will look at how we can measure grass direction from images to better understand wind patterns in Savoonga, Alaska. Residents have long used grass orientation as part of their Traditional Ecological Knowledge (TEK) to guide daily practices like hunting and farming, but changes in the Arctic climate and limited historical wind data from insufficient weather detection technology amidst harsh conditions have made this knowledge harder to rely on. By using image analysis, we hope to support and recalibrate this TEK so the community can track shifts in wind direction that affect weather, sea ice, and subsistence activities. To explore this, we will test the Histogram of Oriented Gradients (HOG) on both simulated and real images of grass. A simulation study of AI generated images will provide test cases such as grass uniformly blown in one direction, grass blocked by obstacles, and mixed vegetation to assess algorithmic accuracy against known orientations and wind directions. We will then apply HOG to real grass images from the St. Lawrence University Living Lab and compare that against the known wind direction data that is collected.

## Load R packages and Python libraries

```{r load_r_packages, warning=FALSE, message=FALSE}
# Load R packages

library(reticulate)
library(tidyverse)
library(mapsapi)
library(mapboxapi)
library(magick)

```

```{r, warning=FALSE, message=FALSE}
use_virtualenv("C:/Users/FranM/grass-hog", required = TRUE)

# Check configuration
py_config()
```

```{python load_python_modules}
# Load Python Libraries
import matplotlib.pyplot as plt
import pandas as pd
from skimage.io import imread, imshow
from skimage.transform import resize
from skimage.feature import hog
from skimage import data, exposure
import matplotlib.pyplot as plt
from skimage import io
from skimage import color
from skimage.transform import resize
import math
import os
from skimage.feature import hog
import numpy as np
```

## Get HOG Features for Grass Images

```{python}
# Create directories to have images (input) and where the datasets of mags and angles will be stored
input_dir = "../images"
output_data_dir = "../output/angles_mags"
output_weighted_dir = "../output/weighted_mean"

# Now list all files in 'input_dir' that have image file extensions (png, jpg, jpeg) and store them in 'image_files'
image_files = [f for f in os.listdir(input_dir) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]

# A loop to run through all the image files in the folder
for image_file in image_files:
    print(f"Processing: {image_file}") # Just to see whats been processed
    image_name = os.path.splitext(image_file)[0]  

    img = color.rgb2gray(io.imread(os.path.join(input_dir, image_file)))

    height = 200
    aspect_ratio = img.shape[0] / img.shape[1]
    width = int(height / aspect_ratio)
    resized_img = resize(img, (height, width))

    # Compute gradients manually
    mag = []
    theta = []

    for i in range(height):
        magnitudeArray = []
        angleArray = []
        for j in range(width):
            if j - 1 < 0:
                Gx = resized_img[i, j + 1] - 0
            elif j + 1 >= width:
                Gx = 0 - resized_img[i, j - 1]
            else:
                Gx = resized_img[i, j + 1] - resized_img[i, j - 1]

            if i - 1 < 0:
                Gy = 0 - resized_img[i + 1, j]
            elif i + 1 >= height:
                Gy = resized_img[i - 1, j] - 0
            else:
                Gy = resized_img[i + 1, j] - resized_img[i - 1, j]

            magnitude = math.sqrt(Gx**2 + Gy**2)
            magnitudeArray.append(round(magnitude, 9))

            if Gx == 0:
                angle = 0.0
            else:
                angle = math.degrees(math.atan(Gy / Gx))
                if angle < 0:
                    angle += 180

            angleArray.append(round(angle, 9))
        mag.append(magnitudeArray)
        theta.append(angleArray)

    mag = np.array(mag)
    theta = np.array(theta)

    dataset_df = pd.DataFrame({
        "theta": theta.flatten(),
        "mag": mag.flatten()
    })
    dataset_df["radian"] = np.deg2rad(dataset_df["theta"])

    dataset_df.to_csv(os.path.join(output_data_dir, f"{image_name}_dataset.csv"), index=False)
    

```

## A loop to use datasets to get circular mean

```{r}
library(circular)
library(readr)
library(stringr)

input_data_dir <- "../output/angles_mags"
output_weighted_dir <- "../output/weighted_datasets"

# get the csv files that were generated from above
dataset_files <- list.files(input_data_dir, pattern = "\\.csv$", full.names = TRUE)

# go through all the datasets
for (file in dataset_files) {
  cat("Processing:", basename(file), "\n") # show whats been processed
  
  df <- read_csv(file, show_col_types = FALSE)
  
  # Extract variables 
  angles_weighted <- df$theta
  magnitudes_weighted <- df$mag
  
  # Compute weighted circular stats
  mean_val <- circular_mean(angles_weighted, w = magnitudes_weighted, axial = TRUE, na.rm = TRUE)
  var_val <- circular_var(angles_weighted, w = magnitudes_weighted, axial = TRUE, na.rm = TRUE)
  median_val <- circular_median(angles_weighted, w = magnitudes_weighted, axial = TRUE, na.rm = TRUE)
  iqr_val <- circular_IQR(angles_weighted, w = magnitudes_weighted, axial = TRUE, na.rm = TRUE)
  quantiles <- circular_quantiles(angles_weighted, w = magnitudes_weighted, axial = TRUE, na.rm = TRUE)
  
  # Create a dataset to store these
  weighted_stats_df <- data.frame(
    image_name = str_remove(basename(file), "_dataset\\.csv"),
    circular_mean = as.numeric(mean_val),
    circular_variance = as.numeric(var_val),
    circular_median = as.numeric(median_val),
    circular_IQR = as.numeric(iqr_val),
    quantile_25 = as.numeric(quantiles[1]),
    quantile_50 = as.numeric(quantiles[2]),
    quantile_75 = as.numeric(quantiles[3])
  )
  
  # --- Save to weighted_datasets folder ---
  output_path <- file.path(output_weighted_dir, paste0(weighted_stats_df$image_name, "_weighted_dataset.csv"))
  write_csv(weighted_stats_df, output_path)
}


```



## Manual Extraction of Data


```{python}
# List for storing images
img_list = []

# Test Grass Image: 
img_list.append(color.rgb2gray(io.imread("../images/grass_image_test.png")))

# Living Lab Image:
img_list.append(color.rgb2gray(io.imread("../images/living_lab.jpg")))

# List to store magnitudes for each image
mag_list = []

# List to store angles for each image
theta_list = []

for x in range(len(img_list)):
    # Get image of interest
    img = img_list[x]
    
    rescaled_file_path = f"../output/plots/grass/{x}.jpg"
    
    # Determine aspect Ratio
    aspect_ratio = img.shape[0] / img.shape[1]
    print("Aspect Ratio:", aspect_ratio)
    
    # Hard-Code height to 200 pixels
    height = 200
    
    # Calculate witdth to maintain same aspect ratio
    width = int(height / aspect_ratio)
    print("Resized Width:", width)
    
    # Resize the image
    resized_img = resize(img, (height, width))
    
    # Replace the original image with the resized image
    img_list[x] = resized_img
  
    
    # list for storing all magnitudes for image[x]
    mag = []
    
    # list for storing all angles for image[x]
    theta = []
    
    for i in range(height):
        magnitudeArray = []
        angleArray = []

        for j in range(width):
            if j - 1 < 0 or j + 1 >= width:
                if j - 1 < 0:
                    Gx = resized_img[i][j + 1] - 0
                elif j + 1 >= width:
                    Gx = 0 - resized_img[i][j - 1]
            else:
                Gx = resized_img[i][j + 1] - resized_img[i][j - 1]

            if i - 1 < 0 or i + 1 >= height:
                if i - 1 < 0:
                    Gy = 0 - resized_img[i + 1][j]
                elif i + 1 >= height:
                    Gy = resized_img[i - 1][j] - 0
            else:
                Gy = resized_img[i + 1][j] - resized_img[i - 1][j]

            magnitude = math.sqrt(pow(Gx, 2) + pow(Gy, 2))
            magnitudeArray.append(round(magnitude, 9))

            if Gx == 0:
                angle = math.degrees(0.0)
            else:
                angle = math.degrees(math.atan(Gy / Gx))
                if angle < 0:
                    angle += 180

            angleArray.append(round(angle, 9))

        mag.append(magnitudeArray)
        theta.append(angleArray)

    # add list of magnitudes to list[x]
    mag_list.append(np.array(mag))

    # add list of angles to angle list[x]
    theta_list.append(np.array(theta))
    
## Extract Gradient Magnitudes and Angles from each Grass Image
    
# Test Image DF of gradient magnitudes and angles
mag_grass_image_test = np.array(mag_list[0])
theta_grass_image_test = np.array(theta_list[0])

# Living Lab Image DF of gradient magnitudes and angles
mag_living_lab = np.array(mag_list[1])
theta_living_lab = np.array(theta_list[1])
    
```


```{r, warning=FALSE, message=FALSE}
# Grass Image Test
grass_image_test_hog_df <- 
  data.frame(mag = as.vector(py$mag_grass_image_test),
             theta = as.vector((py$theta_grass_image_test))) %>%
  mutate(radian = theta*(pi/180))

# Living Lab Image
living_lab_hog_df <- 
  data.frame(mag = as.vector(py$mag_living_lab),
             theta = as.vector((py$theta_living_lab))) %>%
  mutate(radian = theta*(pi/180))

# List of all Data frames: "Add the data frames created above to a list"
grass_standard_df_list = list(grass_image_test_hog_df, living_lab_hog_df)

```


## Create Histograms of Gradient Magnitudes and Angles for Grass Images

# Grass prompt: "Create an overhead (drone style) image of a grassy field where the wind has blown it down in a

# specific direction (135 degrees clockwise from north)"

```{r, warning=FALSE, message=FALSE}
#| code-summary: "Plot histogram of test grass gradient magnitudes and define the magnitude level for later filtering"

# test grass image histogram of gradient mags
grass_image_test_histogram_mag_plot <-
  ggplot(grass_standard_df_list[[1]], 
         aes(x = mag)) +
  geom_histogram(colour = "black", fill = "lightblue") +
  scale_x_continuous() + 
  labs(x = "Gradient Magnitude", 
       y = "Count", 
       title = "Grass Image Test Histogram of Gradient Magnitudes"
       ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

grass_image_test_histogram_mag_plot

# Grass mag filter
grass_image_test_mag_filter <- 0.3

# save image
ggsave("../output/plots/grass_image_test_histogram_mag_plot.jpg", 
       grass_image_test_histogram_mag_plot, 
       width = 6, 
       height = 4, 
       dpi = 300)

```

```{r, warning=FALSE, message=FALSE}
#| code-summary: "Plot histogram of test grass gradient magnitudes and define the magnitude level for later filtering"

# living_lab image histogram of gradient mags
living_lab_histogram_mag_plot <-
  ggplot(grass_standard_df_list[[2]], 
         aes(x = mag)) +
  geom_histogram(colour = "black", fill = "lightblue") +
  scale_x_continuous() + 
  labs(x = "Gradient Magnitude", 
       y = "Count", 
       title = "Living Lab Image Histogram of Gradient Magnitudes"
       ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

living_lab_histogram_mag_plot

# Grass mag filter
living_lab_mag_filter <- 0.3

# save image
ggsave("../output/plots/living_lab_histogram_mag_plot.jpg", 
       living_lab_histogram_mag_plot, 
       width = 6, 
       height = 4, 
       dpi = 300)

```

```{r, warning=FALSE, message=FALSE}
#| code-summary: "Filter each data set of grass image gradients and angles to only contain observations with magnitudes greater than or equal to the respective magnitude levels determined above"

# Create filtered data frames using the filter levels for 
# magnitudes defined above, store all in a list
filtered_grass_standard_df_list <-
  list(grass_image_test_hog_df %>%
         filter(mag >= grass_image_test_mag_filter),
  living_lab_hog_df %>%
         filter(mag >= living_lab_mag_filter))

```

## Generate Histogram Plots for Images Using Standard Histogram

```{r}
#| code-summary: "Plot histogram of test grass gradient angles"

# test grass image histogram of gradient angles
grass_image_test_histogram_theta_plot <-
  ggplot(filtered_grass_standard_df_list[[1]], 
         aes(x = theta)) +
  geom_histogram(colour = "black", fill = "lightblue") +
  scale_x_continuous() + 
  labs(x = "Gradient Angle", 
       y = "Count", 
       title = "Test Grass Image Histogram of Gradient Angles"
       ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

grass_image_test_histogram_theta_plot

# save image
ggsave("../output/plots/grass_image_test_histogram_theta_plot.jpg", 
       grass_image_test_histogram_theta_plot, 
       width = 6, 
       height = 4, 
       dpi = 300)

# living lab grass image histogram of gradient angles
living_lab_histogram_theta_plot <-
  ggplot(filtered_grass_standard_df_list[[2]], 
         aes(x = theta)) +
  geom_histogram(colour = "black", fill = "lightgreen") +  
  scale_x_continuous() + 
  labs(x = "Gradient Angle", 
       y = "Count", 
       title = "Living Lab Grass Image Histogram of Gradient Angles"
       ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

living_lab_histogram_theta_plot

# save image
ggsave("../output/plots/living_lab_histogram_theta_plot.jpg", 
       living_lab_histogram_theta_plot, 
       width = 6, 
       height = 4, 
       dpi = 300)
```

## Generate Polar Plots for Images Using Standard Histogram Binning Technique

```{r, warning=FALSE, message=FALSE}
#| code-summary: "Polar plot of test grass histogram of gradient angles using standard binning technique"

# test grass plot
grass_image_test_plot <-
  ggplot(filtered_grass_standard_df_list[[1]], 
         aes(x = theta)) +
  geom_histogram(colour = "black", 
                 fill = "lightblue", 
                 breaks = seq(0, 360, length.out = 17.5),
                 bins = 9) +
  coord_polar(
    theta = "x", 
    start = 0, 
    direction = 1) +
  scale_x_continuous(limits = c(0,360),
    breaks = c(0, 45, 90, 135, 180, 225, 270, 315), 
    labels = c("N", "NE", "E", "SE", "S", "SW", "W", "NW")
  )+
  labs(title = "Polar Plot of Test Grass Image
       Using Standard HOG Technique") +
  theme_minimal() +
  labs(x = "") +
  theme(axis.title.y = element_blank(),
        plot.title = element_text(hjust = 0.5))

grass_image_test_plot

# save image
ggsave("../output/plots/grass_image_test_standard_polar_plot.jpg", 
       grass_image_test_plot, 
       width = 6, 
       height = 4, 
       dpi = 300)

# living lab grass polar plot
living_lab_plot <-
  ggplot(filtered_grass_standard_df_list[[2]],   # <-- use [[2]] here
         aes(x = theta)) +
  geom_histogram(colour = "black", 
                 fill = "lightgreen",   # optional color change
                 breaks = seq(0, 360, length.out = 17.5),
                 bins = 9) +
  coord_polar(
    theta = "x", 
    start = 0, 
    direction = 1) +
  scale_x_continuous(
    limits = c(0,360),
    breaks = c(0, 45, 90, 135, 180, 225, 270, 315), 
    labels = c("N", "NE", "E", "SE", "S", "SW", "W", "NW")
  ) +
  labs(title = "Polar Plot of Living Lab Grass Image
       Using Standard HOG Technique") +
  theme_minimal() +
  labs(x = "") +
  theme(axis.title.y = element_blank(),
        plot.title = element_text(hjust = 0.5))

living_lab_plot

# save image
ggsave("../output/plots/living_lab_standard_polar_plot.jpg", 
       living_lab_plot, 
       width = 6, 
       height = 4, 
       dpi = 300)
```

## Fit Von Mises Distribution to Grass Orientation Angles

```{r}
filtered_grass_standard_df_list[[1]]
```

```{r}
filtered_grass_standard_df_list[[2]]
```

![](../images/grass_image_test.png)
Original Prompt: "Create an overhead (drone style) image of a grassy field where the wind has blown it down in a specific direction (135 degrees clockwise from north)"

```{r, warning=FALSE}
library(circular)
library(CircStats)  
```


## Using Filtered Data

```{r}

# Test Grass Image
# Convert filtered angles to circular object
angles_test <- circular(filtered_grass_standard_df_list[[1]]$theta, units="degrees")

# Fit von Mises distribution
vm_fit_test <- mle.vonmises(angles_test)

# Extract mean direction (μ) and concentration (κ)
mean_direction_test <- vm_fit_test$mu
concentration_test <- vm_fit_test$kappa

mean_direction_test
concentration_test
```

![](../images/living_lab.jpg)

```{r}
# Living Lab Grass Image
angles_living <- circular(filtered_grass_standard_df_list[[2]]$theta, units="degrees")

# Fit von mises distribution
vm_fit_living <- mle.vonmises(angles_living)

mean_direction_living <- vm_fit_living$mu
concentration_living <- vm_fit_living$kappa

mean_direction_living
concentration_living # look for ways we can change this 

```

## Using Weighted Data 

- look into weighted angles using the magnitudes from the dataset
- what filtering should we choose based on the above
- also maybe make a dummy von mises distribution to be able to tell what different concentrations mean
- rbar (tells us more about concentration? (kappa))

```{r, warning=FALSE}
library(tectonicr)
```

## Compute: 10th and 90th 25th and 75th quantiles (using the documentation we got today), mean, var, median, IQR

```{r}
angles_test_weighted <- grass_standard_df_list[[1]]$theta    
magnitudes_test_weighted <- grass_standard_df_list[[1]]$mag 

circular_mean(angles_test_weighted, w = magnitudes_test_weighted, axial = TRUE, na.rm = TRUE)
circular_var(angles_test_weighted, w = magnitudes_test_weighted, axial = TRUE, na.rm = TRUE)
circular_median(angles_test_weighted, w = magnitudes_test_weighted, axial = TRUE, na.rm = TRUE)
circular_IQR(angles_test_weighted, w = magnitudes_test_weighted, axial = TRUE, na.rm = TRUE)
circular_quantiles(angles_test_weighted, w = magnitudes_test_weighted, axial = TRUE, na.rm = TRUE)

```


```{r}
angles_living_weighted <- grass_standard_df_list[[2]]$theta    
magnitudes_living_weighted <- grass_standard_df_list[[2]]$mag 

circular_mean(angles_living_weighted, w = magnitudes_living_weighted, axial = TRUE, na.rm = TRUE)
circular_var(angles_living_weighted, w = magnitudes_living_weighted, axial = TRUE, na.rm = TRUE)
circular_median(angles_living_weighted, w = magnitudes_living_weighted, axial = TRUE, na.rm = TRUE)
circular_IQR(angles_living_weighted, w = magnitudes_living_weighted, axial = TRUE, na.rm = TRUE)
circular_quantiles(angles_living_weighted, w = magnitudes_living_weighted, axial = TRUE, na.rm = TRUE)

```


```{r}
# Living Lab Grass Image (weighted by magnitude)
angles_living_weighted <- grass_standard_df_list[[2]]$theta      
magnitudes_living_weighted <- grass_standard_df_list[[2]]$mag    

# scale magnitudes to integer counts
# (so large magnitudes contribute more)
magnitudes_scaled <- round(rescale(magnitudes_living_weighted, to = c(1, 10)))

# replicate angles according to scaled weights
angles_rep <- rep(angles_living_weighted, times = magnitudes_scaled)

angles_circ <- circular(angles_rep, units = "degrees")
vm_fit_living_weighted <- mle.vonmises(angles_circ)

mean_direction_living_weighted <- vm_fit_living_weighted$mu
concentration_living_weighted   <- vm_fit_living_weighted$kappa

# Outputs
mean_direction_living_weighted
concentration_living_weighted

```

Let's get pictures. And think about how we are gonna store the data and what about the image are we gonna store. What will be a clean and organised way. Picture file name should have similar name 

Create github for SYE and make Dr. Ramler a collaborator

```{r}
# Weighting the test grass image by the magnitudes
angles_test_weighted <- grass_standard_df_list[[1]]$theta    
magnitudes_test_weighted <- grass_standard_df_list[[1]]$mag 

angles_circ_test <- weighted.mean.circular(angles_test_weighted, magnitudes_test_weighted)

# Fit von Mises distribution
vm_fit_test <- mle.vonmises(angles_circ_test)

# Extract mean direction (μ) and concentration (κ)
mean_direction_test <- vm_fit_test$mu
concentration_test <- vm_fit_test$kappa

mean_direction_test
concentration_test

```

# Simulating the vonmises distribution to find what k, concentration, means:

```{r}
library(circular)

# Simulate three dummy von Mises samples
set.seed(123)
x1 <- rvonmises(200, mu=circular(0, units="degrees"), kappa=0.5)  # low concentration
x2 <- rvonmises(200, mu=circular(0, units="degrees"), kappa=2)    # medium concentration
x3 <- rvonmises(200, mu=circular(0, units="degrees"), kappa=5)    # high concentration

# Quick polar plots
par(mfrow=c(1,3))  # three plots side by side
plot(x1, stack=TRUE, bins=36, main="κ = 0.5")
plot(x2, stack=TRUE, bins=36, main="κ = 2")
plot(x3, stack=TRUE, bins=36, main="κ = 5")

```

## Plot Gradient Magnitudes as Image for each Grass Image

```{python}
# Save gradient magnitudes of Test Grass in image form

plt.figure(figsize=(15, 8))
plt.title('Test Grass Image')
plt.imshow(mag_list[0], cmap="gray")
plt.axis("on")
plt.show()
plt.tight_layout()
plt.savefig("../output/images/grass_image_test_mag.png", dpi=300)
```
